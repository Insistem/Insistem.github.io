<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>BFF应用 | 前端知识荟萃</title>
    <meta name="generator" content="VuePress 1.5.4">
    
    <meta name="description" content="作者：前端小小灶">
    <link rel="preload" href="/blog/assets/css/0.styles.5380bfb8.css" as="style"><link rel="preload" href="/blog/assets/js/app.10236026.js" as="script"><link rel="preload" href="/blog/assets/js/2.d15e92b9.js" as="script"><link rel="preload" href="/blog/assets/js/44.41cee111.js" as="script">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.5380bfb8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">前端知识荟萃</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">概述</a></div><div class="nav-item"><a href="/blog/blog/" class="nav-link router-link-active">内容</a></div> <a href="https://github.com/insistem/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">概述</a></div><div class="nav-item"><a href="/blog/blog/" class="nav-link router-link-active">内容</a></div> <a href="https://github.com/insistem/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0" style="padding-top:10px;"><div class="kitty-main" data-v-2b653b36><span class="stand" data-v-2b653b36></span> <div class="cat" data-v-2b653b36><div class="body" data-v-2b653b36></div> <div class="head" data-v-2b653b36><div class="ear" data-v-2b653b36></div> <div class="ear" data-v-2b653b36></div></div> <div class="face" data-v-2b653b36><div class="nose" data-v-2b653b36></div> <div class="whisker-container" data-v-2b653b36><div class="whisker" data-v-2b653b36></div> <div class="whisker" data-v-2b653b36></div></div> <div class="whisker-container" data-v-2b653b36><div class="whisker" data-v-2b653b36></div> <div class="whisker" data-v-2b653b36></div></div></div> <div class="tail-container" data-v-2b653b36><div class="tail" data-v-2b653b36><div class="tail" data-v-2b653b36><div class="tail" data-v-2b653b36><div class="tail" data-v-2b653b36><div class="tail" data-v-2b653b36><div class="tail" data-v-2b653b36><div class="tail" data-v-2b653b36></div></div></div></div></div></div></div></div></div></div> <p class="sidebar-heading open"><span>前言</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/blog/0.html" class="sidebar-link">介绍</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="bff应用"><a href="#bff应用" class="header-anchor">#</a> <strong>BFF</strong>应用</h3> <p>参考：https://www.jianshu.com/p/eb1875c62ad3 Backend for Frontent</p> <img src="/Users/mpy/Library/Application Support/typora-user-images/image-20200512224622827.png" alt="image-20200512224622827" style="zoom:30%;"> <ul><li>为什么ssr 更利于 SEO？</li></ul> <h2 id="commonjs的理解"><a href="#commonjs的理解" class="header-anchor">#</a> commonjs的理解</h2> <p>借此理解下 module.exports 与 exports 有什么区别</p> <p>可以借助运行shell命令<code>webpack --devtool none --mode development --target node index.js</code>，webpack打包出的文件来看，为什么是这样的</p> <h2 id="npm-包管理"><a href="#npm-包管理" class="header-anchor">#</a> npm 包管理</h2> <ul><li>什么是包
<ul><li>别人写的nodejs模块</li></ul></li> <li>常用的命令
<ul><li>npm init</li> <li>npm install</li> <li>npm uninstall 删除某个包</li> <li>npm config set registry https://registry.npm.taobao.org</li> <li>npm config get registry</li></ul></li></ul> <h3 id="模块介绍"><a href="#模块介绍" class="header-anchor">#</a> 模块介绍</h3> <img src="/Users/mpy/Library/Application Support/typora-user-images/image-20200507000925267.png" alt="image-20200507000925267" style="zoom:50%;"> <h4 id="内置模块"><a href="#内置模块" class="header-anchor">#</a> 内置模块</h4> <p>EventEmitter</p> <ul><li><strong>观察者模式</strong> <ul><li>调用 vs 抛事件
<ul><li>关键在于”不知道被通知者存在“</li> <li>以及”没有人听还能继续下去“</li></ul></li></ul></li></ul> <h4 id="异步"><a href="#异步" class="header-anchor">#</a> 异步</h4> <h5 id="_13-异步-node-js的非阻塞i-o"><a href="#_13-异步-node-js的非阻塞i-o" class="header-anchor">#</a> 13|异步： Node.js的非阻塞I/O</h5> <ul><li>阻塞与非阻塞的区别在于系统接受输入再到输出期间，能不能接收其他输入</li> <li>生活中的例子类比：
<ul><li>系统=食堂阿姨/服务生，输入=点菜，输出=端菜</li> <li>在你点菜到拿到菜这个过程中:</li> <li>饭堂阿姨只能一分一分的给你打菜 -&gt; 阻塞I/O</li> <li>服务生给你点完菜之后还可以服务其他客人 -&gt; 非阻塞I/O</li></ul></li> <li>理解非阻塞I/O的要点在于
<ul><li><em>确定一个进行Input/Output的系统</em></li> <li>思考在I/O过程中，能不能进行其他I/O</li></ul></li> <li>代码演示 - glob（Train-myself/kaikeba/nodejs/gekee-node/4.nonblocking）</li></ul> <img src="/Users/mpy/Library/Application Support/typora-user-images/image-20200507214611166.png" alt="image-20200507214611166" style="zoom:50%;"> <h4 id="_14-异步-异步编程之callback"><a href="#_14-异步-异步编程之callback" class="header-anchor">#</a> 14|异步：异步编程之callback</h4> <ul><li>回调函数格式规范
<ul><li>Error-first callback</li> <li>Node-style callback</li> <li>第一个参数是error，后面的参数才是结果</li></ul></li> <li>异步编程容易出现的问题
<ul><li>回调地狱</li> <li>异步的并发</li></ul></li> <li>历史的解决方案：
<ul><li>node中的async.js</li> <li>Thunk</li></ul></li></ul> <h3 id="_15-异步-事件循环"><a href="#_15-异步-事件循环" class="header-anchor">#</a> 15|异步：事件循环</h3> <ul><li><em>try catch 的异常捕获机制</em> ??
<ul><li>在调用栈中，上层的抛错 throw new Error，会被下层的捕获try catch</li> <li>只能捕获同一个调用栈中的异常</li> <li>代码演示- [（Train-myself/kaikeba/nodejs/gekee-node/5.async-callback/index.js）]</li></ul></li> <li>node中与浏览器的事件循环有何不同</li> <li>调用栈与event-loop</li></ul> <h3 id="_16-异步-异步编程之promise"><a href="#_16-异步-异步编程之promise" class="header-anchor">#</a> 16|异步：异步编程之Promise</h3> <h5 id="promise"><a href="#promise" class="header-anchor">#</a> promise</h5> <ul><li><p>当前事件循环得不到的结果，但未来的事件循环会给到你结果</p></li> <li><p>new Promise((resolve,reject)=&gt;{.....})  中间包裹的东西是个异步操作</p></li> <li><p>是一个状态机</p> <ul><li>pending</li> <li>Fulfilled/resolved</li> <li>Rejected</li> <li><img src="/Users/mpy/Library/Application Support/typora-user-images/image-20200507225623911.png" alt="image-20200507225623911" style="zoom:50%;"></li></ul></li> <li><p>.then 和 .catch</p> <ul><li>resolve状态的Promise 会回调后面的第一个.then</li> <li>rejected状态的promise会回调后面的第一个.catch</li> <li>任何一个rejected状态且后面没有.catch的promise，都会造成浏览器/node环境的全局错误</li></ul></li> <li><p>resolve() 和 rejecte()</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">33</span><span class="token punctuation">)</span> <span class="token comment">// 用来扭转Promise的pending状态为resolved状态</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">80</span><span class="token punctuation">)</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 无法再扭转为rejected</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">80</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token comment">// promise状态变为resolved时会立即出发then中的回调</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p>一旦状态改为resolved状态就不会被再更改为rejected</p></li></ul></li> <li><p>Promise 是如何解决异步流程控制的问题的呢</p> <ul><li>示例演示 - 在原来callback方式的interview函数基础上改成promise</li> <li>执行then和catch会返回一个新promise，该promise最终状态根据then和catch的回调函数的执行结果决定
<ul><li>如果回调函数最终是throw，该Promise是rejected状态</li> <li>如果回调函数最终是return，该Promise是resolved状态</li> <li>但如果回调函数最终return了一个Promise，该Promise会和回调函数return的Promise状态保持一致</li></ul></li></ul></li></ul> <h3 id="_17-异步-异步编程之async-await"><a href="#_17-异步-异步编程之async-await" class="header-anchor">#</a> 17|异步：异步编程之async-await</h3> <h5 id="async-await"><a href="#async-await" class="header-anchor">#</a> async/await</h5> <ul><li>Async function 是Promise的语法糖封装</li> <li>异步编程的重疾方案 - 以同步的方式写异步
<ul><li>await关键字可以&quot;暂停”async function 的执行</li> <li>await 关键字可以以同步的写法获取Promise的执行结果</li> <li>try-catch 可以获取await所得到的错误</li></ul></li></ul> <h4 id="小知识点"><a href="#小知识点" class="header-anchor">#</a> 小知识点</h4> <ul><li><p>只加了async的函数代表了什么含义</p> <ul><li>相当于<code>return new Promise(resolve=&gt; resolve())</code>，也就是说return了一个理解resolved的promise对象</li> <li><code>async function demo(){ return 123}</code> 相当于 <code>function demo(){ return new Promise(resolve=&gt;resolve(123))}</code></li></ul></li> <li><p>调用栈的理解</p> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'demo'</span><span class="token punctuation">,</span>  <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// 打印顺序</span>
<span class="token operator">&gt;</span> <span class="token number">2</span>
<span class="token operator">&gt;</span> demo <span class="token keyword">undefined</span>
</code></pre></div></li></ul></li></ul> <h3 id="_18-http-什么是http服务器"><a href="#_18-http-什么是http服务器" class="header-anchor">#</a> 18|HTTP：什么是HTTP服务器？</h3> <h4 id="是什么"><a href="#是什么" class="header-anchor">#</a> 是什么</h4> <ul><li>应用层协议</li> <li>五层网络协议
<ul><li>应用层  - HTTP HTTPS</li> <li>运输层 - TCP UDP</li> <li>网络层 - IPv4 IPv6</li> <li>数据链路层 - mac</li> <li>物理层 - 光纤</li></ul></li></ul> <h4 id="练习-石头剪刀布-online版"><a href="#练习-石头剪刀布-online版" class="header-anchor">#</a> 练习——石头剪刀布-online版</h4> <h3 id="_21-http-用express重构石头剪刀布"><a href="#_21-http-用express重构石头剪刀布" class="header-anchor">#</a> 21|HTTP：用express重构石头剪刀布</h3> <h4 id="要了解一个框架-最好的方法是"><a href="#要了解一个框架-最好的方法是" class="header-anchor">#</a> 要了解一个框架，最好的方法是</h4> <ul><li>了解他的关键功能</li> <li>推导出他要解决的问题是什么</li></ul> <h4 id="features"><a href="#features" class="header-anchor">#</a> Features</h4> <ul><li>Robust routing</li> <li>Focus on high performance</li> <li>Super-high test coverage</li> <li>HTTP helpers (redirection, catching, etc)</li> <li>View system supporting 14+ template engines</li> <li>Content negotiation</li> <li>Executable for generating applications quickly</li></ul> <h4 id="核心功能"><a href="#核心功能" class="header-anchor">#</a> 核心功能</h4> <ul><li><p>路由</p></li> <li><p>request/response 简化</p> <ul><li>request： pathname, query, etc</li> <li>response： send() , json(), jsonp() , etc
<ul><li>response.status(200)</li> <li>response.send('hello world')</li></ul></li></ul></li> <li><p>中间件 - 洋葱模型</p> <ul><li><p>缺陷1 ：对异步的支持不太好，催生了下一代的koa</p></li> <li><p>缺陷2 ： 通过res传递自定义变量，怪怪的</p></li> <li><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 使用方式</span>
app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span> <span class="token comment">// 这里接受很多个function</span>
   <span class="token string">'/game'</span><span class="token punctuation">,</span>
   <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span>res<span class="token punctuation">,</span>next</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
     <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span>res<span class="token punctuation">,</span>next</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token punctuation">)</span>
</code></pre></div></li></ul></li></ul> <h3 id="_22-http-用koa重构石头剪刀布游戏"><a href="#_22-http-用koa重构石头剪刀布游戏" class="header-anchor">#</a> 22|HTTP:用koa重构石头剪刀布游戏</h3> <h4 id="koa核心功能"><a href="#koa核心功能" class="header-anchor">#</a> koa核心功能</h4> <ul><li>Midlleware
<ul><li>使用 async function 实现的中间件</li> <li>有”暂停执行“能力</li> <li>在异步的情况下也符合洋葱模型</li></ul></li> <li>Context - ctx.status,  ctx.req  或者在上面挂一些自定义的变量，比express中将一些自定义的变量挂在res上更符合语义
<ul><li>ctx.status = 200</li> <li>ctx.body = 'hello world'</li></ul></li> <li>极简设计 - 路由需要中间件引入 - 使用koa-mount</li></ul> <h4 id="小问题"><a href="#小问题" class="header-anchor">#</a> 小问题</h4> <ul><li><div class="language-js extra-class"><pre class="language-js"><code>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>
  <span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>
app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>
  <span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">'/game'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>

<span class="token comment">// 这种顺序的写法，会导致请求 http://localhost:3000/game 总是会被上面那个拦截</span>
<span class="token comment">// 必须要把‘/’ 这个放到下面才行</span>
</code></pre></div></li></ul> <h3 id="_23-rpc调用-什么是rpc调用"><a href="#_23-rpc调用-什么是rpc调用" class="header-anchor">#</a> 23|RPC调用：什么是RPC调用？</h3> <h4 id="rpc调用"><a href="#rpc调用" class="header-anchor">#</a> RPC调用</h4> <ul><li>Remote Procedure Call 远程过程调用</li></ul> <h4 id="与ajax的异同"><a href="#与ajax的异同" class="header-anchor">#</a> 与Ajax的异同</h4> <ul><li>相同点
<ul><li>都是两个计算机间的网络通信</li> <li>需要双方约定一个数据格式</li></ul></li> <li>不同点
<ul><li>不一定使用DNS作为寻址服务</li> <li>应用层协议一般不使用HTTP
<ul><li>二进制协议 - 更小的数据包体积</li> <li>二进制协议 - 更快的编解码速率</li></ul></li> <li>基于TCP或UDP协议</li></ul></li></ul> <h4 id="tcp通信方式"><a href="#tcp通信方式" class="header-anchor">#</a> TCP通信方式</h4> <ul><li>单工通信：单向独木桥</li> <li>半双工通信：双向独木桥（也叫轮番单工）</li> <li>全双工通信：双向车道</li></ul> <h3 id="_24-rpc调用-node-buffer编解码二进制数据包"><a href="#_24-rpc调用-node-buffer编解码二进制数据包" class="header-anchor">#</a> 24|RPC调用：node  Buffer编解码二进制数据包</h3> <ul><li>Buffer.from()</li> <li>Buffer.alloc() : 创建指定长度的二进制</li> <li>Buffer.writeInt8()</li> <li>手动将<code>{name:'ss', age:12}</code>的对象转为二进制协议所需要的二进制数据，肯定是很麻烦，有没有类似<code>JSON.stringify()</code>的函数，一键生成呢
<ul><li>protocol buffer - google提供的 - https://developers.google.com/protocol-buffers/docs/proto</li> <li>npm - protocol buffers - https://www.npmjs.com/package/protocol-buffers</li></ul></li></ul> <h3 id="_25-rpc调用-node-js-net建立多路复用的rpc通道"><a href="#_25-rpc调用-node-js-net建立多路复用的rpc通道" class="header-anchor">#</a> 25|RPC调用：Node.js net建立多路复用的RPC通道</h3> <p>这一节不是很明白？？？？</p> <h3 id="_26-项目启动-整体需求分析"><a href="#_26-项目启动-整体需求分析" class="header-anchor">#</a> 26|项目启动：整体需求分析</h3> <ul><li>三个页面
<ul><li>首页</li> <li>详情页</li> <li>课程播放页</li> <li>app下载页</li></ul></li> <li>设计网站的架构</li></ul> <h3 id="_28-课程详情-详情需求解构"><a href="#_28-课程详情-详情需求解构" class="header-anchor">#</a> 28|课程详情：详情需求解构</h3> <ul><li><p>解构</p> <ul><li>使用RPC通信从后台服务器获取数据</li></ul></li> <li><p>模板引擎</p> <ul><li>include 子模板</li> <li>xss过滤 模板helper函数</li></ul></li></ul> <h3 id="_29-课程详情-将es6模板字符串转换为模板引擎"><a href="#_29-课程详情-将es6模板字符串转换为模板引擎" class="header-anchor">#</a> 29|课程详情：将ES6模板字符串转换为模板引擎</h3> <ul><li>Node.js中常用模板引擎是ejs</li> <li>通过vm模块编译JS形成的函数- <code>vm.runInNewContext（）</code> <ul><li>xss过滤，模板helper函数</li> <li>include子模板</li></ul></li> <li>TODO：
<ul><li>了解下其他的模板解析：https://www.jianshu.com/p/3337f8a13917</li> <li>状态机 + AST +  正则匹配 ：https://github.com/zhangxiang958/zhangxiang958.github.io/issues/39</li> <li>demo: https://segmentfault.com/a/1190000005705169</li> <li>https://juejin.im/post/5a04a08ff265da430e4e9d42</li></ul></li></ul> <h3 id="_30-课程详情页-详情页需求实现"><a href="#_30-课程详情页-详情页需求实现" class="header-anchor">#</a> 30|课程详情页：详情页需求实现</h3> <ul><li><p>RPC的封装</p> <ul><li>通过8位的header，解决粘包问题，全双工通信的实现
<ul><li><a href="https://www.nodejs.red/#/nodejs/net?id=tcp-%e7%b2%98%e5%8c%85%e9%97%ae%e9%a2%98" target="_blank" rel="noopener noreferrer">粘包问题解释<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>如何跟后端协商的实现全双工通信？？</li></ul></li></ul></li> <li><p>node包：<code>easy_sock</code> - 快速开发基于tcp连接的二进制网络协议接口的nodejs模块</p></li> <li><p>node包：<code>proto-buffers</code>使用基于文件的协议</p></li> <li><p><code>Buffer.readUInt32LE与</code> <a href="https://vimsky.com/examples/usage/node-js-buffer-readuint32le-method.html" target="_blank" rel="noopener noreferrer">readUInt32BE<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li> <li><p>TODO： 这里有个BUG，只能请求一次，然后服务端报错 -</p></li> <li><div class="language-js extra-class"><pre class="language-js"><code></code></pre></div></li></ul> <p>internal/buffer.js:51
throw new ERR_BUFFER_OUT_OF_BOUNDS();
^
RangeError [ERR_BUFFER_OUT_OF_BOUNDS]: Attempt to write outside buffer bounds</p> <div class="language- extra-class"><pre class="language-text"><code>
### 31|课程播放页：需求解构

- API服务 - RESTful
- 简单易懂
- 可以快速搭建
- 在数据的聚合方面有很大劣势
- API服务 - GraphQL
- [什么是 GraphQL？](https://www.zhihu.com/question/264629587?sort=created)
- 专注数据聚合，前端要什么就返回什么

### 32|课程播放页：实现

- GraphQL
- Facebook开发的实现API服务的库
- 让前端有“自定义查询”数据的能力
- Koa-graphql 中间件
- TODO:自己使用这个写的例子 启动服务之后，在地址栏输入 `http://localhost:4000/?query={comment{id}}` 总是报错`{&quot;errors&quot;:[{&quot;message&quot;:&quot;Expected {} to be a GraphQL schema.&quot;}]}` 不知道是为什么
- **思考题**
- 自己工作中，有哪些是可以通过GraphQL来处理的场景
- 后端为啥是一个微服务，占用一个端口吗？

### 34|课程列表页：需求解构

- 后端需要渲染列表
- 首屏加速
- SEO
- 前端也需要渲染列表
- 无刷新过滤、排序
- 前后端使用一套模板渲染，开发效率高
- 前后端同构
- 同一个模板/组件，可在浏览器渲染，也可在Node.js渲染

### 35|课程列表页： 服务端渲染

- 前后端同构
- ReactDOMServer.renderToString()
- VueServerRenderer.renderToString()
- 使用React实现SSR（服务端渲染）
- 需要安装包
 - @babel/preset-react 
 - @babel/register
 - react
 - react-dom

- 同构的关键

- 注意职责分离
 - 处理数据
 - 环境

- 同构的理解

- ###### [JS核心理论之《SPA、CSR、SSR、Prerender原理浅析》](https://zhuanlan.zhihu.com/p/138356519)

- 服务端渲染的技术方案

- 纯后台技术实现

 - 利用后台语言模板引擎进行服务器端渲染方案落地。对于前端来说，可以利用node作为中间件，然后利用node的ejs模板引擎负责数据填充，最后通过node路由响应机制输出html字符串给客户端浏览器进行渲染；

- 构建同构应用

 - 同构应用就是可以同时运行在客户端和服务器端的Web应用；这种一般采用webpack构建工具和开源工具进行实现；以下会以Vue来介绍同构应用；这种实现方式相对于上面的方案更复杂，开发难度大；但是可以享受到Vue框架带来的便利（响应式数据，路由无感切换等便利）。前提需要“客户端激活”

 - &gt; **客户端激活：官方术语，可以理解为服务器端渲染成html字符串给浏览器之后，需要引入客户端的bundleClient文件，这个环节就交给客户端处理了；**

- ###### 【小项目】[Vue SSR技术方案落地实现—构建同构应用](https://juejin.im/post/5cf79cee6fb9a07eeb139725)

- 实现一个小DEMO
- babel的设置学习
 - 详见 - /项目架构/工程能力.md

### 36|课程列表页：需求实现



</code></pre></div></div> <!----> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/insistem/blog/edit/master/docs/blog/nodejs/nodejs实战.md" target="_blank" rel="noopener noreferrer">帮阿猪改善此页面！</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----> <div style="margin-top:30px;"><div class="el-row" style="margin-left:-10px;margin-right:-10px;"><div class="el-col el-col-24 el-col-sm-0 el-col-md-2 el-col-lg-4" style="padding-left:10px;padding-right:10px;display:block;"><div style="width:1px;height:1px;"></div></div> <div class="el-col el-col-24 el-col-sm-24 el-col-md-18 el-col-lg-16" style="padding-left:10px;padding-right:10px;"><div class="el-card box-card is-always-shadow"><div class="el-card__header"><div class="clearfix"><span>温馨提示喵</span></div></div><div class="el-card__body"> <div class="el-row" style="margin-left:-10px;margin-right:-10px;"><div class="el-col el-col-24 el-col-xs-24 el-col-sm-12" style="padding-left:10px;padding-right:10px;"><div class="el-image"><div class="image-slot"><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/assets/img/loading.gif" style="width:100%;"></div><!----></div></div> <div class="el-col el-col-24 el-col-xs-24 el-col-sm-12" style="padding-left:10px;padding-right:10px;"><div class="copyright-text"><div>本书采用“保持署名—非商用”<a href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">创意共享4.0许可证</a>。只要保持原作者署名和非商用，您可以自由地阅读、分享、修改本书。</div> <div>作者：<a href="https://github.com/godbasin" target="_blank">被删</a></div></div></div></div></div></div></div></div></div></footer> <!---->  <div class="gitalk-container theme-default-content"><div id="gitalk-container" class="content"></div></div></main> <div id="kitty-container"><span><div role="tooltip" id="el-popover-726" aria-hidden="true" class="el-popover el-popper" style="width:undefinedpx;display:none;"><!----><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/2code2.jpg" class="image"> <div class="text">牡羊猪的猫粮罐</div> </div><div id="kitty" style="background:url(https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/assets/img/kitty0.svg);"></div></span> <div class="el-dialog__wrapper" style="display:none;"><div role="dialog" aria-modal="true" aria-label="牡羊猪是这样渐渐胖成猪的喵（点击图片可以切换噢）" class="el-dialog" style="margin-top:15vh;"><div class="el-dialog__header"><span class="el-dialog__title">牡羊猪是这样渐渐胖成猪的喵（点击图片可以切换噢）</span><button type="button" aria-label="Close" class="el-dialog__headerbtn"><i class="el-dialog__close el-icon el-icon-close"></i></button></div><!----><!----></div></div></div></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.10236026.js" defer></script><script src="/blog/assets/js/2.d15e92b9.js" defer></script><script src="/blog/assets/js/44.41cee111.js" defer></script>
  </body>
</html>
