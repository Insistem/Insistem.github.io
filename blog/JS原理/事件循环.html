<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>事件循环 - event loop | 前端知识荟萃</title>
    <meta name="generator" content="VuePress 1.5.4">
    
    <meta name="description" content="作者：前端小小灶">
    <link rel="preload" href="/blog/assets/css/0.styles.5380bfb8.css" as="style"><link rel="preload" href="/blog/assets/js/app.10236026.js" as="script"><link rel="preload" href="/blog/assets/js/2.d15e92b9.js" as="script"><link rel="preload" href="/blog/assets/js/22.2af44e08.js" as="script">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.5380bfb8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">前端知识荟萃</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">概述</a></div><div class="nav-item"><a href="/blog/blog/" class="nav-link router-link-active">内容</a></div> <a href="https://github.com/insistem/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">概述</a></div><div class="nav-item"><a href="/blog/blog/" class="nav-link router-link-active">内容</a></div> <a href="https://github.com/insistem/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0" style="padding-top:10px;"><div class="kitty-main" data-v-2b653b36><span class="stand" data-v-2b653b36></span> <div class="cat" data-v-2b653b36><div class="body" data-v-2b653b36></div> <div class="head" data-v-2b653b36><div class="ear" data-v-2b653b36></div> <div class="ear" data-v-2b653b36></div></div> <div class="face" data-v-2b653b36><div class="nose" data-v-2b653b36></div> <div class="whisker-container" data-v-2b653b36><div class="whisker" data-v-2b653b36></div> <div class="whisker" data-v-2b653b36></div></div> <div class="whisker-container" data-v-2b653b36><div class="whisker" data-v-2b653b36></div> <div class="whisker" data-v-2b653b36></div></div></div> <div class="tail-container" data-v-2b653b36><div class="tail" data-v-2b653b36><div class="tail" data-v-2b653b36><div class="tail" data-v-2b653b36><div class="tail" data-v-2b653b36><div class="tail" data-v-2b653b36><div class="tail" data-v-2b653b36><div class="tail" data-v-2b653b36></div></div></div></div></div></div></div></div></div></div> <p class="sidebar-heading open"><span>前言</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/blog/0.html" class="sidebar-link">介绍</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="事件循环-event-loop"><a href="#事件循环-event-loop" class="header-anchor">#</a> 事件循环 - event loop</h1> <h2 id="问题"><a href="#问题" class="header-anchor">#</a> 问题：</h2> <ul><li>是不是多个微任务会在同一个宏任务中执行，这是JS引擎设定的？</li></ul> <h2 id="大纲"><a href="#大纲" class="header-anchor">#</a> 大纲</h2> <ul><li>常见执行顺序问题 -</li> <li>https://juejin.im/post/5a72df6cf265da3e2c3870b9</li> <li>js运行机制 - 单线程 - 为啥是单线程</li> <li>js的事件循环是怎么回事 -
<ul><li>https://blog.csdn.net/Fundebug/article/details/86487117</li> <li>https://juejin.im/post/5e5c7f6c518825491b11ce93</li> <li>https://juejin.im/post/59e85eebf265da430d571f89</li></ul></li> <li>node中也是js为啥会跟浏览器中的不一样
<ul><li>https://mp.weixin.qq.com/s/RNYYNR7A01V-Y2aC1wNsGw</li> <li>https://blog.fundebug.com/2019/01/15/diffrences-of-browser-and-node-in-event-loop/</li></ul></li> <li>微任务 - 宏任务
<ul><li>Macro task: setTimeout、MessageChannel、postMessage、setImmediate</li> <li>Micro Task:MutationObsever 和 Promise.then</li> <li>执行优先级上，主线程任务 &gt; microtask &gt; macrotask</li></ul></li> <li>promise 前身 jQuary中的deffered</li> <li>Vue中的事件循环 nextTick是怎么回事 , 与node中的nextTick是否一样 - https://segmentfault.com/a/1190000008589736</li> <li>常见面试题 - setTimeout / promise / await async 执行顺序</li> <li>如何实现js中的多线程 - webworker</li> <li>[可以查看事件循环的网站](http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D 、 https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)</li> <li><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly" target="_blank" rel="noopener noreferrer">查看调用栈<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h1 id="解释"><a href="#解释" class="header-anchor">#</a> 解释</h1> <p>被称作事件循环的原因在于，同步的任务可能会生成新的任务，因此它一直在不停的查找新的事件并执行。一次循环的执行称之为 tick，在这个循环里执行的代码被称作 task，而整个过程是不断重复的。</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>上面代码在输出 <strong>1</strong> 之后(谨慎使用！我的浏览器就被卡死了~)，定时器被塞到任务队列里，然后主线程继续往下执行，碰到一个死循环，导致任务队列里的任务永远不会被执行，因此不会输出 <strong>2</strong></p> <p>1 4 7 2 3 5 6</p> <p>调用栈的理解  - 结合try-catch的捕捉机制</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'demo'</span><span class="token punctuation">,</span>  <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// 打印顺序</span>
<span class="token operator">&gt;</span> <span class="token number">2</span>
<span class="token operator">&gt;</span> demo <span class="token keyword">undefined</span>
</code></pre></div><blockquote><p>栈中的代码会调用各种外部API，它们在任务队列中加入各种事件(onClick,onLoad,onDone)，只要栈中的代码执行完毕(js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空)，主线程就回去读取任务队列，在按顺序执行这些事件对应的回调函数。</p> <p>也就是说主线程从任务队列中读取事件，这个过程是循环不断的，所以这种运行机制又成为Event Loop(事件循环)。</p> <p>宏任务包括： script（整体代码），I/O，setTimeout, setInterval, requestAnimationFrame(web), setImmediate(node)</p> <p>微任务包括： Promise, MutationObserver, process.nextTick(node, <strong>这里注意node中的这个任务一定是在这轮宏任务执行结束，执行微任务队列任务之前执行，即使写在promise后面</strong>)</p></blockquote> <p>![image-20200709172012452](/Users/mpy/Library/Application Support/typora-user-images/image-20200709172012452.png)</p> <h3 id="预备知识"><a href="#预备知识" class="header-anchor">#</a> 预备知识</h3> <p>1、 为啥说JS是单线程语言？</p> <p>2、 因为JS是单线程语言，意味着所有任务都需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着</p> <p>3、 所有任务可以分为两种，一种为同步任务，另一种为异步任务。<strong>同步任务</strong>指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；<strong>异步任务</strong>指的是，不进入主线程，而进入&quot;任务队列&quot;的任务，。</p> <p>4、 异步执行的运行机制：：</p> <h5 id="事件循环"><a href="#事件循环" class="header-anchor">#</a> 事件循环</h5> <img src="/Users/mpy/Library/Application Support/typora-user-images/image-20200709175854321.png" alt="image-20200709175854321" style="zoom:50%;"> <h2 id="事件循环和消息队列"><a href="#事件循环和消息队列" class="header-anchor">#</a> 事件循环和消息队列</h2> <h4 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h4> <p>每个渲染进程都有一个主线程，并且主线程非常繁忙，要处理的任务有 处理DOM、计算样式、处理布局、处理JS任务、各种输入事件。要让这 么多不同类型的任务在主线程中有条不紊地执行，这就需要一个系统来统筹调度这些任务， 这个统筹调度系统就是我们今天要讲的消息队列和事件循环系统。</p> <h4 id="事件循环-2"><a href="#事件循环-2" class="header-anchor">#</a> 事件循环</h4> <p>为了协调这些任务有条不紊地在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用 一个 for 循环，不断地从这些任务队列中取出任务并执行任务。</p> <h4 id="消息队列"><a href="#消息队列" class="header-anchor">#</a> 消息队列</h4> <p><strong>消息队列是一种数据结构，可以存放要执行的任务</strong>。它符合队列“<strong>先进先 出</strong>”的特点，也就是说<strong>要添加任务的话，添加到队列的尾部;要取出任务的话，从队列头部 去取</strong>。</p> <p>消息队列中的任务类型： 输入事件(鼠标滚动、点击、移动)、微任务、文件读写、WebSocket、JavaScript 定时器，还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等</p> <h4 id="如何解决单个任务执行时长过久的问题"><a href="#如何解决单个任务执行时长过久的问题" class="header-anchor">#</a> 如何解决单个任务执行时长过久的问题</h4> <p>因为所有的任务都是在单线程中执行的，所以每次只能执行一个任务，而其他任务就都处于等待状态。如果其中一个任务执行时间过久，那么下一个任务就要等待很长时间。JS通过回调功能来规避这种问题，也就是让要执行的耗时长的 JavaScript 任务滞后执行</p> <h4 id="整个过程"><a href="#整个过程" class="header-anchor">#</a> 整个过程</h4> <p>渲染进程中所有运行在主线程上的任务都需要先添加到消息队列，然后事件循环系统再按照顺序执行消息队列中的任务。</p> <p>其他进程想要发送任务给页面主线程，那么先通过 IPC 把任务发送给渲染进程的 IO 线程，IO 线程再把任务发送给页面主线程（IO线程，用来负责和其它进程IPC通信的）</p> <h4 id="通过settimeout看延迟任务是怎么执行的"><a href="#通过settimeout看延迟任务是怎么执行的" class="header-anchor">#</a> 通过setTimeout看延迟任务是怎么执行的</h4> <p>处理完消息队列中 的一个任务之后，就开始执行 ProcessDelayTask 函数。该函数会根据发 起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。等到期的任务执行完 成之后，再继续下一个循环过程 通过定时器发起的任务就被保存到延迟队列</p> <p>raf VS setTimeout : requestAnimationFrame与浏览器刷新同步，适合做动画，而setTimeout就算设置了16.7延迟，也可 能会因为当前任务的执行时间过长而延迟</p> <h4 id="通过xmlhttprequest理解回调"><a href="#通过xmlhttprequest理解回调" class="header-anchor">#</a> 通过XMLHttpRequest理解回调</h4> <h6 id="回调函数-将一个函数作为参数传递给另外一个函数-那作为参数的这个函数就是回调函数"><a href="#回调函数-将一个函数作为参数传递给另外一个函数-那作为参数的这个函数就是回调函数" class="header-anchor">#</a> 回调函数 - 将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是<strong>回调函数</strong></h6> <ol><li><strong>同步回调</strong>： 回调函数 callback 是在主函数 doWork 返回之前执行的</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1</span> <span class="token keyword">let</span> <span class="token function-variable function">callback</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token number">2</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'i am do homework'</span><span class="token punctuation">)</span> <span class="token number">3</span><span class="token punctuation">}</span>
<span class="token number">4</span> <span class="token keyword">function</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token parameter">cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">5</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'start do work'</span><span class="token punctuation">)</span>
<span class="token number">6</span> <span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">7</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'end do work'</span><span class="token punctuation">)</span>
<span class="token number">8</span><span class="token punctuation">}</span>
<span class="token number">9</span> <span class="token function">doWork</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span>
</code></pre></div><ol start="2"><li>异步回调：回调函数在主函数外部执行的过程</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1</span> <span class="token keyword">let</span> <span class="token function-variable function">callback</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token number">2</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'i am do homework'</span><span class="token punctuation">)</span> 
<span class="token number">3</span><span class="token punctuation">}</span>
<span class="token number">4</span> <span class="token keyword">function</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token parameter">cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token number">5</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'start do work'</span><span class="token punctuation">)</span>
  <span class="token number">6</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>cb<span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>
  <span class="token number">7</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'end do work'</span><span class="token punctuation">)</span>
<span class="token number">8</span><span class="token punctuation">}</span>
<span class="token number">9</span> <span class="token function">doWork</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span>
</code></pre></div><p>当循环系统在执行一个任务的时候，都要为这个任务维护一个 <strong>系统调用栈</strong>。这个<strong>系统调用栈</strong>类似于 JavaScript 的调用栈，只不过系统调用栈是 Chromium 的开发语言 C++ 来维护的.</p> <p>![image-20200711175137167](/Users/mpy/Library/Application Support/typora-user-images/image-20200711175137167.png)</p> <p>这幅图记录了一个 Parse HTML 的任务执行过程，其中黄色的条目表示执行 JavaScript 的 过程，其他颜色的条目表示浏览器内部系统的执行过程。</p> <p>Parse HTML 任务在执行过程中会遇到一系列的子过程，比如在 解析页面的过程中遇到了 JavaScript 脚本，那么就暂停解析过程去执行该脚本，等执行完 成之后，再恢复解析过程。然后又遇到了样式表，这时候又开始解析样式表......直到整个任 务执行完成。</p> <p>需要说明的是，整个 Parse HTML 是一个完整的任务，在执行过程中的脚本解析、样式表 解析都是该任务的子过程，其下拉的长条就是执行过程中调用栈的信息。</p> <p><strong>XMLHttpRequest</strong> <strong>运作机制</strong></p> <img src="/Users/mpy/Library/Application Support/typora-user-images/image-20200711175002528.png" alt="image-20200711175002528" style="zoom:67%;"> <h4 id="如何处理高优先级的任务"><a href="#如何处理高优先级的任务" class="header-anchor">#</a> 如何处理高优先级的任务</h4> <p>所有任务来自消息队列，如果想要执行一个任务，必须添加到消息队列的尾部，如果前面有很多任务排队了，势必会影响实时性；采用同步通知的方式，又会影响当前任务的执行效率。那么如何权衡<strong>效率</strong>和<strong>实时性</strong>呢？</p> <h4 id="宏任务"><a href="#宏任务" class="header-anchor">#</a> 宏任务</h4> <p>渲染事件(如解析 DOM、计算布局、绘制); 用户交互事件(如鼠标点击、滚动页面、放大缩小等); JavaScript 脚本执行事件; 网络请求完成、文件读写完成事件。我们把这些消息队列中的任 务称为<strong>宏任务</strong></p> <p>宏任务可以满足我们大部分的日常需求，不过如果有对时间精度要求较高的需求，宏任务就难以胜任了。页面的渲染事件、各种 IO 的完成事件、执行 JavaScript 脚本的事件、用 户交互的事件等都随时有可能被添加到消息队列中，而且添加事件是由系统操作的， JavaScript 代码不能准确掌控任务要添加到队列中的位置，控制不了任务在消息队列中的 位置，所以很难控制开始执行任务的时间</p> <h4 id="微任务"><a href="#微任务" class="header-anchor">#</a> 微任务</h4> <p>有哪些微任务 - MutationObserver、Promise</p> <p>通常我们把消息队列中的任务称为<strong>宏任务</strong>，每个宏任务中都关联了一个<strong>微任务队列</strong>，在执行 宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不 会影响到宏任务的继续执行，因此也就解决了执行效率的问题。</p> <p>等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务， 而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这 样也就解决了实时性问题。</p> <p>微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。</p> <h4 id="微任务产生的时机和执行微任务队列的时机"><a href="#微任务产生的时机和执行微任务队列的时机" class="header-anchor">#</a> 微任务产生的时机和执行微任务队列的时机</h4> <p>第一种方式是使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修 改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产 生 DOM 变化记录的微任务。</p> <p>第二种方式是使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也 会产生微任务。</p> <p>通过 DOM 节点变化产生的微任务或者使用 Promise 产生的微任务都会被 JavaScript 引擎 按照顺序保存到微任务队列中。</p> <h4 id="异步回调有两种方式"><a href="#异步回调有两种方式" class="header-anchor">#</a> 异步回调有两种方式</h4> <h6 id="_1-异步回调函数封装成一个宏任务-添加到消息队列尾部-当循环系统执行到该任-务的时候执行回调函数-。-settimeout-和-xmlhttprequest-的回调函数都是通过这种方式来实现的"><a href="#_1-异步回调函数封装成一个宏任务-添加到消息队列尾部-当循环系统执行到该任-务的时候执行回调函数-。-settimeout-和-xmlhttprequest-的回调函数都是通过这种方式来实现的" class="header-anchor">#</a> 1. <strong>异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任 务的时候执行回调函数</strong> 。  setTimeout 和 XMLHttpRequest 的回调函数都是通过这种方式来实现的</h6> <h6 id="_2-执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数-这通"><a href="#_2-执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数-这通" class="header-anchor">#</a> 2. 执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通</h6> <p>常都是以微任务形式体现的</p> <h4 id="事件循环-宏任务-微任务"><a href="#事件循环-宏任务-微任务" class="header-anchor">#</a> 事件循环+宏任务/微任务</h4> <p>在执行一个 ParseHTML 的宏任务，在执行过程中，遇到了 JavaScript 脚本， 那么就暂停解析流程，进入到 JavaScript 的执行环境。从图中可以看到，全局上下文中包 含了微任务列表。</p> <p>在 JavaScript 脚本的后续执行过程中，分别通过 Promise 和 removeChild 创建了两个微 任务，并被添加到微任务列表中。接着 JavaScript 执行结束，准备退出全局执行上下文， 这时候就到了检查点了，JavaScript 引擎会检查微任务列表，发现微任务列表中有微任 务，那么接下来，依次执行这两个微任务。等微任务队列清空之后，就退出全局执行上下文。</p> <p>微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。</p> <p>综上所述， MutationObserver 采用了“<strong>异步 + 微任务</strong>”的策略。</p> <p>通过<strong>异步</strong>操作解决了同步操作的<strong>性能问题</strong>; 通过<strong>微任务</strong>解决了<strong>实时性的问题</strong>。</p> <h6 id="为什么是全局上下文中存储的微任务队列"><a href="#为什么是全局上下文中存储的微任务队列" class="header-anchor">#</a> 为什么是全局上下文中存储的微任务队列？？</h6> <p>微任务队列跟JS是绑定在一起的？？只有在执行JS过程中才会产生微任务？</p> <img src="/Users/mpy/Library/Application Support/typora-user-images/image-20200711221517833.png" alt="image-20200711221517833" style="zoom:67%;"> <p>![image-20200711221539227](/Users/mpy/Library/Application Support/typora-user-images/image-20200711221539227.png)</p> <p>1 rand</p></div> <!----> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/insistem/blog/edit/master/docs/blog/JS原理/事件循环.md" target="_blank" rel="noopener noreferrer">帮阿猪改善此页面！</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----> <div style="margin-top:30px;"><div class="el-row" style="margin-left:-10px;margin-right:-10px;"><div class="el-col el-col-24 el-col-sm-0 el-col-md-2 el-col-lg-4" style="padding-left:10px;padding-right:10px;display:block;"><div style="width:1px;height:1px;"></div></div> <div class="el-col el-col-24 el-col-sm-24 el-col-md-18 el-col-lg-16" style="padding-left:10px;padding-right:10px;"><div class="el-card box-card is-always-shadow"><div class="el-card__header"><div class="clearfix"><span>温馨提示喵</span></div></div><div class="el-card__body"> <div class="el-row" style="margin-left:-10px;margin-right:-10px;"><div class="el-col el-col-24 el-col-xs-24 el-col-sm-12" style="padding-left:10px;padding-right:10px;"><div class="el-image"><div class="image-slot"><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/assets/img/loading.gif" style="width:100%;"></div><!----></div></div> <div class="el-col el-col-24 el-col-xs-24 el-col-sm-12" style="padding-left:10px;padding-right:10px;"><div class="copyright-text"><div>本书采用“保持署名—非商用”<a href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">创意共享4.0许可证</a>。只要保持原作者署名和非商用，您可以自由地阅读、分享、修改本书。</div> <div>作者：<a href="https://github.com/godbasin" target="_blank">被删</a></div></div></div></div></div></div></div></div></div></footer> <!---->  <div class="gitalk-container theme-default-content"><div id="gitalk-container" class="content"></div></div></main> <div id="kitty-container"><span><div role="tooltip" id="el-popover-2737" aria-hidden="true" class="el-popover el-popper" style="width:undefinedpx;display:none;"><!----><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/2code2.jpg" class="image"> <div class="text">牡羊猪的猫粮罐</div> </div><div id="kitty" style="background:url(https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/assets/img/kitty2.svg);"></div></span> <div class="el-dialog__wrapper" style="display:none;"><div role="dialog" aria-modal="true" aria-label="牡羊猪是这样渐渐胖成猪的喵（点击图片可以切换噢）" class="el-dialog" style="margin-top:15vh;"><div class="el-dialog__header"><span class="el-dialog__title">牡羊猪是这样渐渐胖成猪的喵（点击图片可以切换噢）</span><button type="button" aria-label="Close" class="el-dialog__headerbtn"><i class="el-dialog__close el-icon el-icon-close"></i></button></div><!----><!----></div></div></div></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.10236026.js" defer></script><script src="/blog/assets/js/2.d15e92b9.js" defer></script><script src="/blog/assets/js/22.2af44e08.js" defer></script>
  </body>
</html>
