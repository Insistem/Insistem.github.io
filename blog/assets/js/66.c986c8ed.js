(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{518:function(t,a,e){"use strict";e.r(a);var r=e(58),_=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"浏览器工作原理篇"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器工作原理篇"}},[t._v("#")]),t._v(" 浏览器工作原理篇")]),t._v(" "),e("h2",{attrs:{id:"课程目标"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#课程目标"}},[t._v("#")]),t._v(" 课程目标")]),t._v(" "),e("p",[t._v("完成一个toy-browser")]),t._v(" "),e("h2",{attrs:{id:"课程问题汇总"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#课程问题汇总"}},[t._v("#")]),t._v(" 课程问题汇总")]),t._v(" "),e("ul",[e("li",[t._v("粘包")]),t._v(" "),e("li",[t._v("后端返回的数据，分成多大的包是由什么控制的呢")]),t._v(" "),e("li",[t._v("状态机")])]),t._v(" "),e("h2",{attrs:{id:"课程笔记"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#课程笔记"}},[t._v("#")]),t._v(" 课程笔记")]),t._v(" "),e("h3",{attrs:{id:"week05"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#week05"}},[t._v("#")]),t._v(" week05")]),t._v(" "),e("h4",{attrs:{id:"内容"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内容"}},[t._v("#")]),t._v(" 内容")]),t._v(" "),e("p",[t._v("通过 "),e("code",[t._v("net")]),t._v("来模拟 "),e("code",[t._v("HTTP")]),t._v("请求，模拟一个像浏览器一样的能发送HTTP请求的客户端")]),t._v(" "),e("ul",[e("li",[t._v("处理发送请求的请求头请求体 - class Request")]),t._v(" "),e("li",[t._v("处理响应的流式数据 - class ResponseParser\n"),e("ul",[e("li",[t._v("需要将流式数据处理成如下格式")]),t._v(" "),e("li",[e("img",{staticStyle:{zoom:"50%"},attrs:{src:"/Users/mpy/Library/Application Support/typora-user-images/image-20200601192901338.png",alt:"image-20200601192901338"}})]),t._v(" "),e("li",[t._v("服务端返回的响应数据，是分成很多包的，指不定在哪里被截断，客户端触发 "),e("code",[t._v("data")]),t._v("回调")]),t._v(" "),e("li",[t._v("使用状态机")])])])]),t._v(" "),e("h4",{attrs:{id:"作业"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#作业"}},[t._v("#")]),t._v(" 作业")]),t._v(" "),e("p",[t._v("课上代码敲完即可")]),t._v(" "),e("h3",{attrs:{id:"week06"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#week06"}},[t._v("#")]),t._v(" week06")]),t._v(" "),e("h4",{attrs:{id:"内容-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内容-2"}},[t._v("#")]),t._v(" 内容")]),t._v(" "),e("h5",{attrs:{id:"有限状态机"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#有限状态机"}},[t._v("#")]),t._v(" 有限状态机")]),t._v(" "),e("blockquote",[e("p",[e("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E7%B1%B3%E5%88%A9%E5%9E%8B%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA",target:"_blank",rel:"noopener noreferrer"}},[t._v("Mealy "),e("OutboundLink")],1),t._v("：在计算理论中，米利型有限状态机（英语：Mealy machine）是基于它的当前状态和输入生成输出的有限状态自动机（更精确的叫有限状态变换器）。这意味着它的状态图将为每个转移边包括输入和输出二者。与输出只依赖于机器当前状态的摩尔有限状态机不同，它的输出与当前状态和输入都有关。但是对于每个 Mealy 机都有一个等价的 Moore 机，该等价的 Moore 机的状态数量上限是所对应 Mealy 机状态数量和输出数量的乘积加 1（|S’|=|S|*|Λ|+1）")])]),t._v(" "),e("p",[t._v("作业： 挑战题：我们如何用状态机处理完全未知的 pattern（选做）")]),t._v(" "),e("h4",{attrs:{id:"http协议-语法与词法分析-三"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http协议-语法与词法分析-三"}},[t._v("#")]),t._v(" HTTP协议+语法与词法分析（三）")]),t._v(" "),e("h5",{attrs:{id:"预习内容"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#预习内容"}},[t._v("#")]),t._v(" 预习内容")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://time.geekbang.org/column/article/80240",target:"_blank",rel:"noopener noreferrer"}},[t._v("浏览器：一个浏览器是如何工作的？（阶段一）"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://time.geekbang.org/column/article/80260",target:"_blank",rel:"noopener noreferrer"}},[t._v("浏览器：一个浏览器是如何工作的？（阶段二）"),e("OutboundLink")],1)])]),t._v(" "),e("h5",{attrs:{id:"内容-html的解析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内容-html的解析"}},[t._v("#")]),t._v(" 内容 - HTML的解析")]),t._v(" "),e("h6",{attrs:{id:"解析请求回来的html代码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解析请求回来的html代码"}},[t._v("#")]),t._v(" 解析请求回来的html代码")]),t._v(" "),e("p",[t._v("字节流--\x3e状态机--\x3e词token--\x3e栈--\x3eDOM树")]),t._v(" "),e("h6",{attrs:{id:"浏览器处理过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器处理过程"}},[t._v("#")]),t._v(" 浏览器处理过程")]),t._v(" "),e("p",[t._v("url--(http)->html--(parse)->dom--(css computing)->dom with css --(layout)--\x3edom with position--(render)--\x3ebitmap")]),t._v(" "),e("h6",{attrs:{id:"html-parse"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#html-parse"}},[t._v("#")]),t._v(" HTML Parse")]),t._v(" "),e("p",[t._v("EOF 的使用：end-of-file")]),t._v(" "),e("p",[t._v("第一步")]),t._v(" "),e("p",[t._v("• parser接受HTML文本作为参数，返回一颗DOM树")]),t._v(" "),e("p",[t._v("第二步——创建状态机")]),t._v(" "),e("p",[t._v("我们用FSM（状态机）来实现HTML的分析")]),t._v(" "),e("p",[t._v("• 在HTML标准中，已经规定了HTML的状态 - 详见"),e("a",{attrs:{href:"https://html.spec.whatwg.org/multipage/parsing.html#tokenization",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTML的词法分析规范"),e("OutboundLink")],1),t._v(" 12.2.5 Tokenization")]),t._v(" "),e("p",[t._v("• Toy-Browser只挑选其中一部分状态，完成一个最简版本")]),t._v(" "),e("p",[t._v("第三步——解析标签")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("主要的标签有：开始标签，结束标签和自封闭标签")])]),t._v(" "),e("li",[e("p",[t._v("在这一步我们暂时忽略属性")])]),t._v(" "),e("li",[e("p",[t._v("小插件 - 动图直观展示状态机HTML解析过程(fms-git.html)")])])]),t._v(" "),e("p",[t._v("第四步——创建元素")]),t._v(" "),e("p",[t._v("• 在状态机中，除了状态迁移，我们还会要加入业务逻辑")]),t._v(" "),e("p",[t._v("• 我们在标签结束状态提交标签token")]),t._v(" "),e("p",[t._v("第五步——处理属性")]),t._v(" "),e("p",[t._v("• 属性值分为单引号、双引号、无引号三种写法，因此需要较多状")]),t._v(" "),e("p",[t._v("态处理")]),t._v(" "),e("p",[t._v("• 处理属性的方式跟标签类似")]),t._v(" "),e("p",[t._v("• 属性结束时，我们把属性加到标签Token上")]),t._v(" "),e("p",[t._v("第六步——构建DOM树")]),t._v(" "),e("p",[t._v("• 从标签构建DOM树的基本技巧是使用栈")]),t._v(" "),e("p",[t._v("• 遇到开始标签时创建元素并入栈，遇到结束标签时出栈")]),t._v(" "),e("p",[t._v("• 自封闭节点可视为入栈后立刻出栈")]),t._v(" "),e("p",[t._v("• 任何元素的父元素是它入栈前的栈顶")]),t._v(" "),e("p",[t._v("第七步——文本节点")]),t._v(" "),e("p",[t._v("• 文本节点与自封闭标签处理类似")]),t._v(" "),e("p",[t._v("• 多个文本节点需要合并")]),t._v(" "),e("ul",[e("li")])])}),[],!1,null,null,null);a.default=_.exports}}]);