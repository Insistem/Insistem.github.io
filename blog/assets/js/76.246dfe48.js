(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{511:function(v,t,_){"use strict";_.r(t);var a=_(58),r=Object(a.a)({},(function(){var v=this,t=v.$createElement,_=v._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"对js的认识"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对js的认识"}},[v._v("#")]),v._v(" 对js的认识")]),v._v(" "),_("p",[v._v("js是函数式编程，弱类型的语言 ，在java中声明一个变量还得指定变量的类型，")]),v._v(" "),_("p",[v._v("js中的操作符，"),_("em",[v._v("位操作符没咋用过呀")])]),v._v(" "),_("img",{staticStyle:{zoom:"20%"},attrs:{src:"/Users/mpy/Library/Application Support/typora-user-images/image-20200325101138964.png",alt:"image-20200325101138964"}}),v._v(" "),_("p",[v._v("\\1. 3sum")]),v._v(" "),_("h2",{attrs:{id:"链表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[v._v("#")]),v._v(" 链表")]),v._v(" "),_("h3",{attrs:{id:"与数组的对比"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#与数组的对比"}},[v._v("#")]),v._v(" 与数组的对比")]),v._v(" "),_("ul",[_("li",[v._v("优点：链表这种数据结构，在删除插入新增数据时，比数组花费的代价更小")]),v._v(" "),_("li",[v._v("缺点： 无法通过下标直接获取数据")])]),v._v(" "),_("p",[v._v("作业：")]),v._v(" "),_("p",[v._v("141")]),v._v(" "),_("p",[v._v("142")]),v._v(" "),_("p",[v._v("206")]),v._v(" "),_("p",[v._v("跳表")]),v._v(" "),_("p",[v._v("时间复杂度 空间复杂度")]),v._v(" "),_("p",[v._v("约瑟夫环")]),v._v(" "),_("p",[v._v("环形链表")]),v._v(" "),_("p",[v._v("跳表")]),v._v(" "),_("p",[v._v("哈希表 二分查找")]),v._v(" "),_("h2",{attrs:{id:"数据结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[v._v("#")]),v._v(" 数据结构")]),v._v(" "),_("h3",{attrs:{id:"链表-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#链表-2"}},[v._v("#")]),v._v(" 链表")]),v._v(" "),_("h3",{attrs:{id:"栈-队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#栈-队列"}},[v._v("#")]),v._v(" 栈 队列")]),v._v(" "),_("p",[v._v("思考问题：")]),v._v(" "),_("p",[v._v("为啥数组中 pop方法 比 shift方法更耗时")]),v._v(" "),_("h3",{attrs:{id:"二叉树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二叉树"}},[v._v("#")]),v._v(" 二叉树")]),v._v(" "),_("ul",[_("li",[v._v("判断相同二叉树  100题")]),v._v(" "),_("li",[v._v("二叉树的遍历方式 - （前、中、后）使用迭代和遍历两种方式实现\n"),_("ul",[_("li",[v._v("144 -- 前序遍历")]),v._v(" "),_("li",[v._v("94 -- 中序遍历")]),v._v(" "),_("li",[v._v("145 -- 后序遍历")])])]),v._v(" "),_("li",[v._v("二叉搜索树 - 节点的值大于left所有的值 小于right 所有的值\n"),_("ul",[_("li",[v._v("如何验证是否是一个二叉搜索树 - 98题")]),v._v(" "),_("li",[v._v("递归+迭代")]),v._v(" "),_("li",[v._v("思路： 中序遍历，其实就是一个从小到大的序列")])])]),v._v(" "),_("li",[v._v("104题 - 二叉树的最大深度\n"),_("ul",[_("li",[v._v("设计递归")]),v._v(" "),_("li",[v._v("递归是如何进行的")]),v._v(" "),_("li",[v._v("递归是如何结束的")])])]),v._v(" "),_("li",[v._v("235题 - 二叉搜索树的最近祖先")]),v._v(" "),_("li",[v._v("236题 - 二叉树的最近祖先 - 难")])]),v._v(" "),_("h5",{attrs:{id:"广度优先-深度优先"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#广度优先-深度优先"}},[v._v("#")]),v._v(" 广度优先 深度优先")]),v._v(" "),_("p",[v._v("参考 - "),_("a",{attrs:{href:"https://juejin.im/post/5c9a468c51882531f12dcd7c",target:"_blank",rel:"noopener noreferrer"}},[v._v("图解DFS与BFS"),_("OutboundLink")],1)]),v._v(" "),_("ul",[_("li",[v._v("深度优先: DFS (depth first search)\n"),_("ul",[_("li",[v._v("其实二叉树的前序、中序、后序遍历，本质上也可以认为是深度优先遍历")]),v._v(" "),_("li",[v._v("如何实现一个DFS - 栈\n"),_("ul",[_("li",[v._v("自后向前追溯曾经访问过的路径，就叫做"),_("strong",[v._v("回溯")])]),v._v(" "),_("li",[v._v("要想实现回溯，可以利用栈的先入后出特性，也可以采用递归的方式（因为递归本身就是基于方法调用栈来实现）")])])])])]),v._v(" "),_("li",[v._v("广度优先：BFS（breadth first search）\n"),_("ul",[_("li",[v._v("其实二叉树的层序遍历，本质上也可以任务是广度优先遍历")]),v._v(" "),_("li",[v._v("如何实现一个BFS - 队列\n"),_("ul",[_("li",[v._v("把遍历过的顶点按照之前的遍历顺序重新回顾，就叫做重放")]),v._v(" "),_("li",[v._v("一层一层由内而外的遍历方式")])])])])])]),v._v(" "),_("h5",{attrs:{id:"前-中-后序遍历介绍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前-中-后序遍历介绍"}},[v._v("#")]),v._v(" 前 中 后序遍历介绍")]),v._v(" "),_("ul",[_("li",[v._v("前： 自 -> left -> right")]),v._v(" "),_("li",[v._v("中：left ->自 -> right")]),v._v(" "),_("li",[v._v("后：left ->right -> 自")])]),v._v(" "),_("img",{staticStyle:{zoom:"60%"},attrs:{src:"http://qapw1lk5y.bkt.clouddn.com/imgimage-20200608174951989.png",alt:"image-20200608174951989"}}),v._v(" "),_("p",[v._v("前序：1 2 4 5 3 6")]),v._v(" "),_("p",[v._v("中序：4 2 5 1 6 3")]),v._v(" "),_("p",[v._v("后序：4 5 2 6 3 1")]),v._v(" "),_("h2",{attrs:{id:"算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#算法"}},[v._v("#")]),v._v(" 算法")]),v._v(" "),_("h3",{attrs:{id:"虚拟dom与fiber架构的思考"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom与fiber架构的思考"}},[v._v("#")]),v._v(" 虚拟dom与fiber架构的思考")]),v._v(" "),_("p",[v._v("虚拟dom 用的是递归，没有中间状态的存储，不好终止")]),v._v(" "),_("p",[v._v("fiber架构 在数据结构层面从树变成了链表结构，diff过程变得可以中断")]),v._v(" "),_("h4",{attrs:{id:"fiber架构的理解-搜一搜"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#fiber架构的理解-搜一搜"}},[v._v("#")]),v._v(" fiber架构的理解（搜一搜）")]),v._v(" "),_("h3",{attrs:{id:"算法的思想"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#算法的思想"}},[v._v("#")]),v._v(" 算法的思想")]),v._v(" "),_("h4",{attrs:{id:"二分法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二分法"}},[v._v("#")]),v._v(" 二分法")]),v._v(" "),_("p",[v._v("374 猜数字")]),v._v(" "),_("ul",[_("li",[v._v("leftpad实现 - 二分法的使用案例\n"),_("ul",[_("li",[v._v("位运算优化")])])])]),v._v(" "),_("h1",{attrs:{id:"待学习"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#待学习"}},[v._v("#")]),v._v(" "),_("em",[v._v("待学习")])]),v._v(" "),_("ol",[_("li",[v._v("熟练使用正则表达式")])]),v._v(" "),_("h2",{attrs:{id:"细枝末节"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#细枝末节"}},[v._v("#")]),v._v(" 细枝末节")]),v._v(" "),_("h2",{attrs:{id:"如何深入理解js中的递归"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何深入理解js中的递归"}},[v._v("#")]),v._v(" ### 如何深入理解JS中的递归")]),v._v(" "),_("p",[v._v("JavaScript中的递归就是指函数反复调用自己的过程，函数的调用是建立在堆栈中，在堆栈的顶部函数调用总是第一个弹出的")]),v._v(" "),_("p",[v._v("递归是指函数或子例程反复调用自己的时候。")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("函数调用存储在调用堆栈上 - 参考 https://www.php.cn/js-tutorial-417516.html")])]),v._v(" "),_("li",[_("p",[v._v("自己写个 5的阶乘 递归函数，在Chrome开发工具里面打个断点，看看callback就明白了")])])]),v._v(" "),_("h3",{attrs:{id:"js堆栈-参考-https-segmentfault-com-a-1190000009693516"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#js堆栈-参考-https-segmentfault-com-a-1190000009693516"}},[v._v("#")]),v._v(" js堆栈 - 参考 https://segmentfault.com/a/1190000009693516")]),v._v(" "),_("p",[v._v("> JavaScript 中的变量分为基本类型和引用类型。")]),v._v(" "),_("p",[v._v("> "),_("img",{attrs:{src:"evernotecid://E34CC73B-9F39-4A8E-87BD-01970B037860/appyinxiangcom/18794174/ENResource/p2183",alt:"e84f8ef6920419b55b26645e63f8d810.png"}})]),v._v(" "),_("h4",{attrs:{id:"栈内存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#栈内存"}},[v._v("#")]),v._v(" 栈内存")]),v._v(" "),_("p",[v._v("俗称作用域，")]),v._v(" "),_("p",[v._v("作用：")]),v._v(" "),_("p",[v._v("为js代码提供执行的环境（执行js代码的地方）。")]),v._v(" "),_("p",[v._v("基本数据类型是直接存放在栈内存中的。")]),v._v(" "),_("h4",{attrs:{id:"栈内存释放"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#栈内存释放"}},[v._v("#")]),v._v(" 栈内存释放")]),v._v(" "),_("p",[v._v("一般情况下，函数执行形成的栈内存，函数执行完，浏览器会把形成的栈内存自动释放。")]),v._v(" "),_("p",[v._v("有时候函数执行完成，栈内存无法释放（被外部占用了）。")]),v._v(" "),_("p",[v._v("全局作用域在加载页面时形成，在关闭页面时销毁（window）")]),v._v(" "),_("h4",{attrs:{id:"堆内存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆内存"}},[v._v("#")]),v._v(" 堆内存")]),v._v(" "),_("p",[v._v("堆内存用于存储引用数据类型值的（相当于存储的仓库）。")]),v._v(" "),_("p",[v._v("对象存储的是键值对。")]),v._v(" "),_("p",[v._v("函数存储的是代码字符串。")]),v._v(" "),_("h4",{attrs:{id:"堆内存释放"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆内存释放"}},[v._v("#")]),v._v(" 堆内存释放")]),v._v(" "),_("p",[v._v("堆内存利用空对象指针null来释放空间。")]),v._v(" "),_("p",[v._v("var obj = {};此时当前对象对应的堆内存被变量obj占用，无法销毁空间。")]),v._v(" "),_("p",[v._v("obj = null;由于null是空对象指针（不指向任何的堆内存），此时上一次的堆内存就没有被占用了，谷歌浏览器会在空闲时间把没有被占用的堆内存自动释放（销毁/回收）")])])}),[],!1,null,null,null);t.default=r.exports}}]);