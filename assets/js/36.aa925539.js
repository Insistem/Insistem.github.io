(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{557:function(t,e,r){"use strict";r.r(e);var a=r(58),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h4",{attrs:{id:"弄懂watcher类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#弄懂watcher类"}},[t._v("#")]),t._v(" 弄懂Watcher类")]),t._v(" "),r("p",[t._v("这里究竟做了什么，我的理解是响应式需要 Observer，Dep，Watcher，而Watcher的创建是跟组件挂钩的，那这里的响应式是怎么回事，难道就是说设置了响应式，只要这个属性的值发生变化，那么使用了这个属性的地方就会触发，这不就是计算属性吗？可以这里也没有见到计算属性呀")]),t._v(" "),r("p",[t._v("可以看看这里面究竟是怎么写的，怎么进行依赖")]),t._v(" "),r("p",[t._v("是不是可以这么理解")]),t._v(" "),r("p",[t._v("​     因为这里对current的getter, setter 进行了设置，那么在任何用到current的地方，肯定首先会触发它的getter，然后把这个依赖收集进去，等setter的时候从依赖列表中拿出来，全部触发一遍。但是依赖是什么呢？？依赖可能就是一个函数的重新执行，可以理解成指定的属性的值变化之后，我需要随之改变的东西。依赖有两种形式")]),t._v(" "),r("div",{staticClass:"language-js extra-class"},[r("pre",{pre:!0,attrs:{class:"language-js"}},[r("code",[r("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 第一种")]),t._v("\n一个组件就会对应一个Watcher 叫做 component watchers \n此种Watcher，属性的值变化之后，随之改变的就是这个组件展示的内容\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 第二种")]),t._v("\n用户自己写在watch属性中的watcher 叫做 user watchers 可能还有多个\n此种Watcher，属性的值变化之后，随之改变的就是重新执行写在watche中的方法，至于做了什么操作，是用户的方法决定的\n\n")])])]),r("p",[t._v("​    Vue.util.defineReactive(this, 'current', initial)")]),t._v(" "),r("h4",{attrs:{id:"结合router的实现-看是怎么利用数据响应式的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#结合router的实现-看是怎么利用数据响应式的"}},[t._v("#")]),t._v(" 结合router的实现，看是怎么利用数据响应式的？")]),t._v(" "),r("h4",{attrs:{id:"感觉理解响应式的核心-watcher在其中起着关键的作用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#感觉理解响应式的核心-watcher在其中起着关键的作用"}},[t._v("#")]),t._v(" 感觉理解响应式的核心，Watcher在其中起着关键的作用")]),t._v(" "),r("p",[t._v("watcher内部做了什么操作，为什么说一个组件对应一个watcher，内部存储了哪些信息")])])}),[],!1,null,null,null);e.default=s.exports}}]);